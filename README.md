# DesignPattern
### 一、创建型模式
#### 1.简单工厂模式
 **定义**：由一个工厂对象决定创建出哪一种类型实例。客户端只需传入工厂类的参数，无心关心创建过程。
 
 **优点**：具体产品从客户端代码中抽离出来，解耦。
 
 **缺点**：工厂类职责过重，增加新的类型时，得修改工程类得代码，违背开闭原则。

#### 2.工厂方法模式

为了解决简单工厂模式的缺点，诞生了工厂方法模式（Factory method pattern）。

**定义**：定义创建对象的接口，让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到了子类进行。

**优点**：

&emsp;具体产品从客户端代码中抽离出来，解耦。

&emsp;加入新的类型时，只需添加新的工厂方法（无需修改旧的工厂方法代码），符合开闭原则。

**缺点**：类的个数容易过多，增加复杂度。

#### 3.抽象工厂模式

抽象工厂模式（Abstract factory pattern）提供了一系列相关或者相互依赖的对象的接口，关键字是“一系列”。

**优点**：

&emsp;具体产品从客户端代码中抽离出来，解耦。

&emsp;将一个系列的产品族统一到一起创建。

**缺点**：拓展新的功能困难，需要修改抽象工厂的接口；

综上所述，抽象工厂模式适合那些功能相对固定的产品族的创建
#### 4.建造者模式
建造者模式也称为生成器模式（Builder Pattern），将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。简单来说就是，相同的过程可以创建不同的产品。

将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。

简单来说就是，相同的过程可以创建不同的产品。

**适用于**：

&emsp;1.一个对象有非常复杂的内部结构（很多属性）

&emsp;2.想将复杂对象的创建和使用分离。

**优点**：

&emsp;1.封装性好，创建和使用分离

&emsp;2.拓展性好，建造类之间独立，一定程度上解耦。

**缺点**：

&emsp;1.产生多余的Builder对象；

&emsp;2.产品内部发生变化，建造者需要更改，成本较大。

#### 5.单例模式
单例模式目的是为了一个类只有一个实例。

**优点**：

&emsp;1.内存中只有一个实例，减少了内存开销；

&emsp;2.可以避免对资源的多重占用；

&emsp;3.设置全局访问点，严格控制访问。

**缺点**：

&emsp;没有接口，拓展困难。

##### 5.1 懒汉模式
最简单，但线程不安全 
com.example.designpattern.singletonpattern.LazySingleton

可以加同步锁解决安全问题，但是同步锁锁的是整个类，比较消耗资源，并且即使运行内存中已经存在LazySingleton，调用其getInstance还是会上锁
